# CS230

Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?

  The Gaming Room was seeking to develop a game called Draw It or Lose It! This game was to run on several platforms and consist of games taht only lasted
  a few seconds, and then would reset and start a new round. 

What did you do particularly well in developing this documentation?
  
  I feel I was able to identify the key differences between the different platforms, and the different tools one could use, as well as identifying 
  soem benefits of cloud based systems and how they positively impact running programs across multiple platforms. 

What about the process of working through a design document did you find helpful when developing the code?

  I found the process of working through the document to be helpful in learning how software architecture is used. I like the top down approach it provided
  and how it made us look deeper into the how and why behind how computers operate and how to make code dance around that. 

If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
  
  Truth be told, i would like to do the whole thing over again, yet with even more detail. I would like to understand the inner workings of software even more
  and provide a deeper understanding of computers. 
  
How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?

  The needs of the user seemed to be that as many people as possile gain access to this program at as cheap as possible. So we looked at serverless architecture 
  that would keep upkeep down, dev cost down, and provide a one time approach where the same code didn't have to be written to accomodate the various platforms. 

How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?

  Understanding how code can speak to the computer unlocks a new level of repsect for code. I think it will allow for a quicker analysis of software and 
  similar approach. 
